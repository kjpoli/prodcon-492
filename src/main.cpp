/*******************************************************************
 * CS 492 Assignment 1: Producers and Consumers
 *
 * Philip Vitale and Kevin Poli
 *
 * I pledge my honor that I have abided by the Stevens Honor System.
 *******************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <sstream>

#include "product.h"
#include "buffer.h"
#include "producer.h"
#include "consumer.h"

//struct for storing the statistics, one instantiated for each algorithm later 
    struct stats {
        int total_time;
        int turnaround[3];
        int average[3];
        int prod_throughput;
        int con_throughput;
    };

void usage() {
    printf( "usage: ./prodcon P1 P2 P3 P4 P5 P6 P7\n"
            "P1: Number of producer threads\n"
            "P2: Number of consumer threads\n"
            "P3: Total number of products to be generated by all producer threads\n"
            "P4: Size of the queue to store products for both producer and consumer threads (0 for unlimited queue size)\n"
            "P5: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for Round-Robin\n"
            "P6: Value of quantum used for round-robin scheduling\n"
            "P7: Seed for random number generator\n" );
}

int main(int argc, char** argv) {
    if (argc != 8) {
        printf("Invalid number of arguments: %d.\n", argc - 1);
        usage();
        return 1;
    }

    int args[7]; 
    
    for (int i = 0; i < 7; ++i) {
        std::istringstream iss(argv[i]);

        if (!(iss >> args[i])) {
            printf("Invalid value for argument P%d\n", i + 1);
            usage();
            return 1;
        }
    }
    
    const struct {
        int prod_threads;
        int con_threads;
        int total_prods;
        int queue_size;
        int scheduler;
        int quantum;
        int seed;
    } params { args[0],args[1],args[2],args[3],args[4],args[5],args[6] };
    
    std::srand(params.seed);
    
    pthread_t producer_thread[params.prod_threads];
    pthread_t consumer_thread[params.con_threads];
    
    Producer producers[params.prod_threads];
    Consumer consumers[params.con_threads];

    Buffer buffer(params.queue_size);

    pthread_mutex_t *buffer_mutex;
    pthread_cond_t *notEmpty;
    pthread_cond_t *notFull;

    pthread_mutex_init(buffer_mutex, NULL);
    pthread_cond_init(notEmpty, NULL);
    pthread_cond_init(notFull, NULL);

    for (int i = 0; i < params.prod_threads; ++i) {
        producers[i] = Producer(i);
        pthread_create(&producer_thread[i], NULL, &(producers[i].produce), &buffer);
    }
    
    for (int i = 0; i < params.con_threads; ++i) {
        consumers[i] = Consumer(i);
        pthread_create(&consumer_thread[i], NULL, &(consumers[i].consume), &buffer);
    }

    for (int i = 0; i < params.prod_threads; ++i) {
        pthread_join(producer_thread[i], NULL);
    }

    for (int i = 0; i < params.con_threads; ++i) {
        pthread_join(consumer_thread[i], NULL);
    }

    return 0;
}
