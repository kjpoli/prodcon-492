/*******************************************************************
 * CS 492 Assignment 1: Producers and Consumers
 *
 * Philip Vitale and Kevin Poli
 *
 * I pledge my honor that I have abided by the Stevens Honor System.
 *******************************************************************/

//#include "procon.h"
//#include "pthread.h"
#include <stdio.h>
#include <stdlib.h>
#include <chrono>
#include <sstream.h>

using namespace std;

class Producer {
        string id;
        int total_prods;
        int prods_over_life;

        void produce() {
            if(prods_over_life != total_prods){
                Product P = new Product(id + to_string(prods_over_life));
            }
        }
        
}

class Buffer {
        pthread_cond_t full;
        pthread_cond_t hasItem;
        unsigned int size;
        deque<Product> queue;

        Buffer(int qsize){
            size = qsize;
        }
        
        void add(){
            
        }
        void remove() {
            
        }
}

class Product {
        string id;
        time_t tstamp;
        unsigned int life;
        //product uids im thinking can be in the form of x(y+) where x is an alphabetical id for the producer and y are sequential numerical ids for its products
        Product(string uid){
            id = uid;
            life = std::rand()%1024;
            // the current time and day from the system clock wrapped in a time_t 
            tstamp = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
            
        }
        
};
//struct for storing the statistics, one instantiated for each algorithm later 
    struct stats {
        int total_time;
        int turnaround[3];
        int average[3];
        int prod_throughput;
        int con_throughput;
    };

void usage() {
    printf( "usage: ./prodcon P1 P2 P3 P4 P5 P6 P7\n"
            "P1: Number of producer threads\n"
            "P2: Number of consumer threads\n"
            "P3: Total number of products to be generated by all producer threads\n"
            "P4: Size of the queue to store products for both producer and consumer threads (0 for unlimited queue size)\n"
            "P5: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for Round-Robin\n"
            "P6: Value of quantum used for round-robin scheduling\n"
            "P7: Seed for random number generator\n" );
}

int main(int argc, char** argv) {
    if (argc != 8) {
        printf("Invalid number of arguments: %d.\n", argc - 1);
        usage();
        return 1;
    }

    int args[7]; 
    
    for (int i = 0; i < 7; ++i) {
        istringstream iss(argv[i]);

        if (!(iss >> args[i])) {
            printf("Invalid value for argument P%d\n", i + 1);
            usage();
            return 1;
        }
    }
    
    const struct {
        int prod_threads;
        int con_threads;
        int total_prods;
        int queue_size;
        int scheduler;
        int quantum;
        int seed;
    } params { args[0],args[1],args[2],args[3],args[4],args[5],args[6] };
    
    std::srand(params.seed);
    
    return 0;
}
